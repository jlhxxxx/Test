# How Google Tests Software——谷歌的测试之道

----------
## 第1章 Google软件测试介绍

本书由来balabalabala……  

* 测试要很灵活，有时候和开发交织在一起，达到无法区分彼此的程度；另外一些时候又完全分离
* 测试并非教条式的、强流程、体力密集型、耗时的
* 测试不能成为导致创新和开发过程变慢的阻碍
* 质量从来不仅仅是测试人员的问题，每个写代码的开发者本身就是测试者
### 1.1 质量不等于测试

质量不等于测试，当你把开发过程和测试放到一起，就像在搅拌机里混合搅拌那样，直到不能区分彼此的时候，你就得到了质量。**开发人员**在写完一段代码之后就要立刻测试这段代码，这意味者**质量更像是一种预防行为，而不是检测**。  

<https://testing.googleblog.com/2007/01/introducing-testing-on-toilet.html>
### 1.2 角色

**you build it, you break it,you fix it.**

测试人员的存在是为了让开发人员的工作更有效率，并且很大一部分体现在避免因马虎而导致的返工。
#### 1.2.1 软件开发工程师（SWE）

传统意义上的开发角色，他们的工作是实现最终用户所使用的功能代码。SWE需要编写与测试代码包括测试驱动的设计、单元测试、参与构建各种大小规模的测试等。
#### 1.2.2 软件测试开发工程师（SET）

也是一个开发角色，但工作重心在可测试性和通用测试基础框架上。他们参与设计评审，近距离观察代码质量与风险。他们会对代码进行重构，编写单元测试框架和自动化测试框架。SET是SWE在代码库上的合作伙伴，相比较SWE是在增加功能性代码或提高性能的代码，SET更关注质量提升和测试覆盖率的增加。SET写代码的目的是可以让SWE测试自己的功能。
#### 1.2.3 测试工程师（TE）

TE把用户放在第一位来思考。TE组织整体质量实践，分析解释测试运行结果，驱动测试执行，构建端到端的自动化测试。
### 1.3 组织结构

Google的组织汇报关系被划分为不同的专注领域，如客户端、地理、apps等，所有的开发工程师都汇报给专注领域的管理者；但测试（包括SET和TE）是与专注领域部门平行的独立存在的部门，称为工程生产力团队。工程生产力团队根据不同产品团队的优先级、复杂度，并与其他产品实际比较后，再分配测试人员。
### 1.4 爬、走、跑

Google在一个产品的基本核心功能实现之后，就立刻对外发布使用，然后从用户那里得到真实反馈，再进行迭代开发，在每次迭代过程中都非常注重质量，一个产品在发布给用户之前，一般都要经历金丝雀版本、开发版本、测试版本、beta或正式发布版本。

* **金丝雀版本**：每日要构建的版本，用来排除过滤一些明显不适合的版本；
* **开发版本**：开发人员日常使用的版本，一般每周发布一个。具有一定的功能并通过了一系列的测试，不能满足需要会被打回金丝雀；
* **测试版本**：通过了持续测试的版本，基本上是最近一个月里的最佳版本，可被挑做内部尝鲜版；
* **beta或发布版**：由非常稳定的测试版本演变过来，并经历了内部使用和通过所有质量考核的一个版本，也是对外发布的第一个版本。
### 1.5 测试类型

Google不使用代码测试、集成测试、系统测试这些命名方式，而是使用小型测试、中型测试、大型测试，着重强调测试的范畴规模而非形式。

* **小型测试**一般都是自动化的。用于验证一个单独函数或独立功能模块的代码是否按预期工作，着重于典型功能性问题、数据损坏、错误条件和大小差一错误等方面验证。由SWE来实现，也有少量SET参加，TE基本不参与。
* **中型测试**通常也是自动化实现的。测试一般涉及两个或两个以上模块之间的交互。测试重点在于验证这些”功能近邻区“之间的交互，以及彼此调用时的功能是否正确。在产品早期开发过程中，独立模块功能开发完毕后，SET会驱动这些测试的实现及运行，SWE深度参与，一起编码、调试和维护测试。在开发后期，TE会通过手动方式（如果自动化较难）或自动化执行这些用例。
* **大型测试**涵盖多个功能模块，使用真实用户使用场景和实际用户数据。关注的是所有模块的集成，但更倾向于结果驱动，验证软件是否满足最终用户的需求。所有三种工程师都会参与到大型测试当中，或自动化测试，或探索式测试。

及时把用户和外部开发者拉进来一起参与，这样可以更有利于判断产品是否满足用户的真正需求。  

**自动化**

## 第2章 软件测试开发工程师（SET）

编写功能代码和编写测试代码在思维方式上有很大不同，对于前者而言，思维模式是**创建**，重点在考虑用户、使用场景和数据流程上；对于后者来说，主要思路是**破坏**，怎样写测试代码用以扰乱分离用户及其数据。
用户开发人员关心这些功能模块如何集成在一起成为一个完整的整体，他们主要考虑系统级别的问题，从用户角度出发，验证独立模块集成在一起是否对最终用户产生价值。
### 2.1 SET的工作

#### 2.1.1 开发和测试流程

公共的代码库、和谐的工程工具、公司范围内的资源共享，成就了丰富的Google内部共享代码库与公共服务。  

Google在平台方面有特定的目标，就是保持简单且统一。  

一个版本的构建目标的构建流程：

1. 针对某个服务，在一个或多个源代码文件中编写一类或一系列功能函数，并保证所有代码可以编译通过；
2. 把这个新服务的构建目标设定为公共库；
3. 通过调用这个库的方式编写一套单元测试用例，把外部重要依赖通过mock模拟实现。对于需要关注的代码路径，使用最常见的输入参数来验证。
4. 为单元测试创建一个测试构建目标；
5. 构建并运行测试目标，做适当的修改调整，直到所有的测试都运行成功；
6. 按照要求运行静态代码分析工具，确保遵守统一的代码风格，且通过一系列常见问题的静态扫描检测；
7. 提交代码申请代码审核，根据反馈再做适当的修改，然后运行所有的单元测试并保证顺利通过。
#### 2.1.2 SET究竟是谁

首先是工程师，使测试存活于所有Google开发过程中；软件工程师意味着测试人员是通过参与设计和代码开发介入到开发流程中；不仅要开发代码，还要知道如何测试的代码。
#### 2.1.3 项目的早期阶段

测试一般不介入，主要精力在如何实验并证明想法的可行性上，早期脚本一般都会被重写。
#### 2.1.4 团队结构

Google产品团队最初由一个技术负责人和一个或更多的项目发起人组成。第一件事——设计文档。
#### 2.1.5 设计文档

最早期的包括项目目标、背景、团队成员、系统设计（大型的包括子系统设计）。在设计阶段，SET在推进项目的同时也可以简化相关项目成员的工作。  
审阅设计文档要点：

* 完整性
* 正确性
* 一致性
* 设计
* 接口与协议
* 测试
#### 2.1.6 接口与协议

SET实现protocol buffer定义的接口与协议，针对各个模块的依赖提供mock或fake的实现，在功能模块还没实现的时候编写集成测试代码。
#### 2.1.7 自动化计划

规模小且目的性强的自动化计划构建：

* 把容易出错的接口做隔离，并针对它们创建mock和fake，这样我们可以控制接口间的交互，确保良好的测试覆盖率；
* 构建一个轻量级自动化框架，控制mock系统的创建和执行。
#### 2.1.8 可测试性

SET第一要务就是可测试性。SET扮演一个质量顾问的角色，提供程序结构和代码风格方面建议给开发人员，这样开发人员可以更好做单元测试。同时提供测试框架方面的建议，使开发人员可以在这些框架的基础上自己写测试。
#### 2.1.9 SET工作流程：一个实例

#### 2.1.10 执行测试

测试自动化不仅仅是自动化测试程序的编写，还要考虑如何编译测试程序、执行、分析、存储和报告测试运行结果。  
集代码编译、测试执行、结果分析、数据存储、报表展示为一体的**测试框架**。
#### 2.1.11 测试大小的定义

1. **小型测试：**Google外一般称单元测试
2. **中型测试：**Google外一般称集成测试
3. **大型测试：**Google外一般称系统测试

**见1.5内容**
#### 2.1.12 测试规模在共享测试平台中的使用

Google测试执行系统利用了测试规模的定义，把运行较快的任务从较慢的任务中挑出来。测试规模在测试运行时间上规定了一个最大值，同时在测试运行消耗资源上也做了要求。在执行测试时，一旦发现任何测试超时或者消耗的资源超过时，会把这个测试任务取消掉并报告这个错误。工程师再调整合适的测试规模标签。

#### 2.1.13 测试规模的益处

![](https://github.com/jlhxxxx/imgur/blob/master/ylzwork/不同测试规模类型的限制.png?raw=true)  

1. **大型测试**
   * 测试最根本最重要的：在考虑外部系统的情况下应用系统是如何工作的。
   * 由于对外部系统有依赖，因此它们是非确定性的。
   * 很宽的测试范畴意味着如果测试运行失败，寻找精准失败根源比较困难。
   * 测试数据准备工作非常耗时。
   * 走到特定的代码路径区域是不切实际的。


2. **中型测试**
   * 由于不需要mock技术，且不受运行时刻的限制，是从大型到小型的过渡。
   * 运行速度相对较快，可以频繁运行。
   * 可以在标准开发环境中运行，开发人员很容易运行它们。
   * 依赖外部系统，本身有不确定性。
   * 运行速度没有小型测试快。


3. **小型测试**

   * 为了更容易被测试到，代码应清晰干净、函数规模小且重点集中。为了方便模拟，系统之间接口需要有良好的定义。
   * 有代码变更时可以立刻运行，从而较早发现缺陷并提供及时反馈。
   * 在所有环境下都可以可靠运行。
   * 较小的测试范围，可以容易做边界场景与错误条件测试。
   * 有特定的范畴，可以很容易隔离错误。
   * 不要做模块间的集成测试。
   * 有时候对子系统的模拟是有难度的。
   * 使用mock或fake环境，可以不与真实环境同步。

   小型测试带来优秀的代码质量、良好的异常处理、优雅的错误报告；大中型测试带来整体产品质量和数据验证。  
**70/20/10原则**：70%小型测试，20%中型测试，10%大型测试。

#### 2.1.14 测试运行要求

* 每个测试和其他测试之间都是独立的，能够以任意顺序来执行。
* 测试不做任何数据持久化方面的工作。在测试用例离开测试环境的时候，要保证测试环境的状态与测试用例开始执行之前的状态是一样的。
### 2.2 测试认证

![](https://github.com/jlhxxxx/imgur/blob/master/ylzwork/测试认证级别1.png?raw=true)  

![](https://github.com/jlhxxxx/imgur/blob/master/ylzwork/测试认证级别2.png?raw=true)  

#### 2.2.1 与测试认证计划创始人的访谈

改变开发环境，把测试工作变成每个功能开发人员的职责。
### 2.3 SET的招聘

SET的面试重点在考察候选人如何思索问题的解决方案，而不是解决方案本身的实现上有多么高雅。
## 第3章 测试工程师（TE）

### 3.1 一种面向用户的测试角色

TE必须首先是工程师的一部分，它综合了开发者仰慕的技术能力和以用户为中心检查软件质量而对开发者产生一定制约的能力。
### 3.2 测试工程师的工作

实验性工作、尚无明确目标或用户故事的早期产品，TE很少参与；即使一个确定要发布的产品，在研发早期阶段，功能还在不断变化，最终功能列表和范畴还没有确定，TE通常没有太多工作可做。TE进入产品时，并不需要从零开始。TE的根本使命是保护用户和业务的利益，使之不受糟糕的设计、令人困惑的用户体验、功能bug、安全和隐私等问题的困扰。  

**TE职责的一般性描述**

* 测试计划和风险分析
* 评审需求、设计、代码和测试。
* 探索式测试。
* 用户场景。
* 编写测试用例。
* 执行测试用例。
* 众包。
* 使用统计。
* 用户反馈。
#### 3.2.1 测试计划

**理想的测试计划**

* 及时更新
* 描述了软件的目标和卖点
* 描述了软件的结构、各种组件和功能特性的名称
* 描述了软件的功能和操作简介
* 不必花过多时间去写，必须随时可以被修改
* 应该描述必测点
* 应该能够在测试中提供有用的信息，从而帮助确定进展以及覆盖率上的不足

**ACC（特质、组件、能力，测试计划的替代方法）指导原则**：

* 避免散漫的文字，推荐使用简明的列表
* 不必推销
* 简洁
* 不要把不重要的、无法执行的东西放进测试计划
* 渐进式的描述
* 指导计划者的思路
* 最终结果应该是测试用例

***做出一个不直接指导测试的计划纯粹是浪费时间***

ACC通过指导计划者依次考察产品的三个维度达成这个目标：描述产品目标的形容词和副词；确定产品各部分、各特性的名词；描述产品实际做什么的动词。

1. A代表特质（Attribute）  

   特质是系统的形容词，代表了产品的品质和特色，是区别于竞争对手的关键。

   * 简单
   * 精确
   * 变化
   * 短小


2. C代表组件（component）  

   组件是构成待建系统的模块，是一个软件之所以如此的核心要素和代码块。

   * 快速行动，动态迭代
   * 不必担心完整性


3. C代表能力（capability）  

   能力是系统的动词，代表着系统在用户指令下完成的动作。它们是对输入的相应、对查询的应答以及代表用户完成的活动。能力处于组件和特质的交点。**组件**通过执行某种功能来满足产品的一个**特质**，这个活动的结果是向用户提供某种**能力**。能力最重要的一个特点是它的可测试性。可以通过以特质为x轴，以组件为y轴建立表格，能力映射到特质和组件上。

   * 一个能力点应该被表达为一个动作，反映了用户使用被测应用完成的一定活动。
   * 一个能力点应当为测试人员提供足够的指导，用以理解在编写测试用例时涉及的变量。
   * 一个能力应当与其他能力组合。
   * 每个能力都应该链接到至少一个测试用例，很多能力需要多个测试用例。
   * 并非所有的能力都是同等重要的。
#### 3.2.2 风险

1. 风险分析  

   **失败频率**：罕见、少见、偶尔、常见  

    **影响**：最大、较大、一些、最小

2. 风险缓解 

   * 围绕风险大的能力点编用户故事，并从中确定低风险的使用场景，再反馈到开发团队，有针对性地增加约束。
   * 编写回归测试用例，确保问题在重现时可以被捕捉到。
   * 编写和运行引发故障的测试用例，推动开发实现恢复和回滚的特性。
   * 插入监听代码，以便更早检测到故障。
   * 插入代码监听软件，发现新旧版本间的行为变化以发现回归问题。
#### 3.2.3 测试用例的生命周期

工具：Google Test Case Manager
#### 3.2.4 bug的生命周期

发现bug——分类bug——修复bug——回归测试  

bug管理系统：Buganizer  

* Assigned to（Assignee，被指派者）
* CC抄送
* Attachments（附件）
* **Blocking（阻塞）：该bug修复之后才能被修复的其他bug的IDs**
* **Depends On（依赖）：阻塞相反**
* Changed（变化）：最后修改的时间
* Changelists（变更列表）
* Component（组件）：有此bug或者需求的实体
* Created（创建于）
* Found In(发现于)：发现问题的版本
* Last mddified(最后修改)
* Notes（备注）
* Priority（优先级）
* Reported by（报告者）
* Resolution（解决方案）
* Severity（严重性）
* Status（状态）
* Summary（摘要）
* **Targeted To（目标）：bug应该被修复的版本**
* Type（类型）：redmine上【跟踪】
* **Verified In（验证于）：问题被修复的版本号**
* Verifier（验证者）

![](https://github.com/jlhxxxx/imgur/blob/master/ylzwork/Buganizer%E4%B8%8Abug%E5%B7%A5%E4%BD%9C%E6%B5%81.png?raw=true)   

